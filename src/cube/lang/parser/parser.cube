use cube.lang.element
use cube.lang.cst.cstNodeType
use cube.lang.cst.cstTranslator
use cube.lang.cst.elementTranslator
use cube.lang.cst.token
use cube.lang.tokenizer.tokenStream
use java.util.map
use cube.lang.parser.cubeDefinition.cubeDefinition
use cube.lang.tokenizer.tokenStream.tokenStream

define parser[T]
  function create(
    definition as parserDefinition[T], translator as cstTranslator[T], tokens as tokenStream)
    me.leftParsers = definition.left
    me.rightParsers = definition.right
    me.translator = translator
    me.tokens = tokens
  end

  function translator as cstTranslator[T] = translator
  function tokens as tokenStream = tokens
  function parse as T = parse(0)

  function parse(rightPrecedence as int) as T
    var token as token = tokens.next
    var leftParser as leftParser[T] = leftParsers.get(token.nodeType)

    if leftParser is null then
      error new syntaxException("Failed to parse '" + token.text + "'.")

    var left as T = leftParser.parse(me, token)

    while rightPrecedence < leftPrecedence
      token = tokens.next
      var rightParser as rightParser[T] = rightParsers.get(token.nodeType)
      left = rightParser.parse(me, left, token)
    end

    output left
  end

  shared
    function parse(text as string) as element
      var parser as parser[element] =
        new parser(cubeDefinition, new elementTranslator, tokenStream(text))

      output parser.parse
    end
  end

  internal
    var rightParsers as map[cstNodeType, rightParser[T]]
    var leftParsers as map[cstNodeType, leftParser[T]]
    var translator as cstTranslator[T]
    var tokens as tokenStream

    function leftPrecedence as int
      var q0 as token = tokens.peek(0)
      if q0 is null then output 0
      var parser as rightParser = rightParsers.get(q0.nodeType)
      output if parser is not null then parser.precedence else 0
    end
  end
end